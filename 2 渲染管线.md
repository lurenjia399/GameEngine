# 渲染流水线

1 输入装配阶段：

​	从显存中读取顶点，索引的数据，设定拓扑方式，在dx中就是向命令列表添加顶点缓冲区和索引缓冲区，设置拓扑方式等

```c++
// 截取了项目中的代码
GetGraphicsCommandList()->IASetVertexBuffers(0, 1, &VBV);
GetGraphicsCommandList()->IASetIndexBuffer(&IBV);
GetGraphicsCommandList()->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY::D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
```

2 顶点着色器阶段：

​	（model transformation）将局部空间的每个顶点，经过线性变换和平移变换到世界空间的位置上

​	（view transformation）将世界空间的坐标点变换到摄像机空间。我们已知世界空间下坐标点求摄像机空间下坐标点。

第一步：求变换矩阵，缩放矩阵就看是否缩放就行了。旋转矩阵就是将世界空间旋转直到坐标轴与摄像机空间坐标轴重合。平移矩阵就是将世界空间原点平移至摄像机空间。至此我们得到了变换矩阵。如果是在同一坐标系下变换（A -> B，已知A求B）就为[平移矩阵] * [旋转矩阵] * [坐标点A] = [坐标点B]，但是view transformation是基变换，所求正好相反（[平移矩阵] * [旋转矩阵] * [坐标点B] = [坐标点A]），所以需要求逆，变成了 [坐标点B] = ([平移矩阵] * [旋转矩阵])-1 * [坐标点A]，即 [坐标点B] = [旋转矩阵]-1 * [平移矩阵]-1 * [坐标点A]，其中旋转矩阵是正交矩阵，逆就是转置，平移矩阵的逆就加个负号。

​	（projection transformation）投影变换:

​				1（orth projection）正交投影，将一个**视矩体转变换到一个中心点在原点的正方体**，此处依然**不采用3d中的变换顺序**，因为视矩体要变成正方体的缩放轴是以正方体原点为中心的，所以需要先将视矩体平移到摄像机空间下的原点，然后在进行缩放操作，也就是

[缩放矩阵] * [平移矩阵] * [坐标点]，无论是缩放还是平移都需要获取到视矩体的各项参数（near plane, far plane, top plane, bottom plane, left plane, right plane）,这些参数主要是通过（near plane, far plane, fov, width/height）求得。

平移就是将视矩体的中心点平移到原点，而缩放就是将位于原点的视矩体的[x,y,z轴]都缩放为2个单位长度。

​				2（pers projection）透视投影，模拟实际情况，近大远小的效果，同样的将**视锥体变换到一个中心点在原点的正方体**，此处的方案**首先将视锥体变换成视矩体，在左乘正交投影矩阵**。此出所需要的参数是（ near plane, far plane），此出需要注意的是矩阵的第三行求法，用远近平面的z值，做特殊值代入法。

在左乘投影矩阵后，此时顶点会位于正方体中，也就是齐次剪裁空间，在这里我们可以保存每个点的w分量（表示每个点在世界空间下的深度值），然后在进行透视除法。

> 对平移矩阵的理解：我们所说的线性变换都是基于原点不变的情况，所以平移不是线性变换，他需要移动原点（这也是三维世界中变换顺序为缩放->旋转->平移的原因）。所以我们就用更高维度的矩阵来表示，拿二维点的平移举例，平移矩阵所构成的列空间是三维的，其中ox,oy都是标准正交基，而oz轴是假设为（dx,dy,1），我们在左乘平移矩阵后，就是将二维点的z分量也就是z方向上的单位向量，变换到列空间中oz轴上的单位向量，左乘完成后，在三维空间中的点，在xoy面上的投影点就是平移后点的位置。

> 对透视除法的理解：我们的投影操作是指把视锥体转换成位于原点的立方体，没有经过维度的变换，所以**投影矩阵应该是满秩的**，投影的过程中包括平移，所以**投影矩阵应该是四维的**，顶点在左乘投影矩阵后，会变换到四维空间中，四维空间中的w分量，决定了三维模型的放大和缩小，所以w应该一直保持为1，即透视除法。（可以类比三维空间中的投影仪，投影仪在墙上投影出一幅2d画面，在三维空间中w分量表示，投影仪与墙的距离，w增大->投影仪与墙的距离增大->2d画面越大，反之同理，所以三维空间中w分量控制了2d画面的放大和缩小，推导回四维空间中就可理解）。

3 曲面细分阶段：能够将网格中的三角形再细分成很多三角形，从而有高模，低模之分，即lod的实现。

4 几何着色器阶段：输入是三角形，可以在这里对三角形进行处理，不满足条件的三角形直接销毁。

5 剪裁：视锥体剪裁。我们是在正方体空间做剪裁。在左乘透视投影之后透视除法之前执行剪裁，用遍历六个面对三角形进行剪裁（这里就有两种情况：剪裁出的是四边形或者是三角形）。

6 光栅化阶段：

​	视口变换，将经历剪裁后的顶点数据左乘视口变换矩阵（先缩放->平移）

​	背面剪裁，通过每个三角形的卷绕方向，通过三角形的法向量是否大于0，来决定此三角形是正向还是反向。

​	顶点属性插值，重心坐标插值来给每个像素上颜色，通过重心坐标来插值计算出三角形中人一顶点的各种数据。

​	片元着色器，由GPU执行，确定每一个片元的颜色

​	输出合并阶段，将片元放到后台缓冲区中。模板测试（模板值未达标的片元不会放到后台缓冲区中，类似平面镜，倒影，平面阴影重叠）-> 深度测试（字面意思把，深度太深的片元会被遮挡就不要了） -> 混合测试（当前片元和已经在后台缓冲区中片元进行融合）
